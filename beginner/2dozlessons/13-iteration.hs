-- Ref: Two Dozen Short Lessons in Haskell by Rex Page
-- Chapter 13 - Iteration and the Common Patters of Repetition

{-
    'Iteration' is the repeated application of a function to the
    data generated by its previous application
    i.e.  f x   => x'
          f x'  => x''
          f x'' => x'''
          etc
          
          or (f . f) x          -- 2 iterations of 'f'
             (f . f . f) x      -- 3 iterations of 'f'
             
    The 'hundredsDigit' function is almost an example, the same function,
    `divMod` is being repeatedly applied to the data produced by a 
    previous call to `divMod`
-}
hundredsDigit n = d2
    where
        (xSansLastDigit,   d0) = n `divMod` 10
        (xSansLast2Digits, d1) = xSansLastDigit `divMod` 10
        (xSansLast3Digits, d2) = xSansLast2Digits `divMod` 10

{-
    what we would really like to do is define a function that
    will generate the next tuple from a previous one.
    
    Implementation Note:
        `divMod` is only available to types from the Integral
        class so 'nextDigit' must have same constraint
-}        
nextDigit :: Integral n => (n,n) -> (n,n)
nextDigit(xShifted, d) = xShifted `divMod` 10

{-
    Example:
        *Main> nextDigit(151,7)
        (15,1)        

    We can use 'nextDigit' to redefine 'hundredsDigit', using true
    iteration i.e. the repeated application of the same function
    
    Implementation Notes: 
        'nextDigit' is constrained by Integral so 'hundredsDigit'
        must have the same constraint.
        
        We don't care what the first value is in the final
        tuple so we can discard it using the wildcard character '_'
    
    
-}
hundredsDigit' :: Integral n => n -> n
hundredsDigit' x = d2
    where
        (_, d2) = (nextDigit . nextDigit . nextDigit) (x,0)

        
{-
    The pattern used in 'hundredsDigit' suggests a way to derive
    a complete decimal number by simply extracting the correct
    sequence of digits through successively longer iterations
    
    [d0, d1, d2, d3, ...] = 
        [d | (s,d) <- [ x `divMod` 10,
                       (nextDigit) (x `divMod` 10),
                       (nextDigit . nextDigit) (x `divMod` 10),
                       (nextDigit . nextDigit . nextDigit)(x `divMod` 10),
                       ...]
        ]
                       
    Haskell provides a function to build a sequence lie the above
    'iterate' which takes the function to be repeatedly applied
    and a starting value generating an infinite sequence
                     
-}        

-- what would happen here?
add1 n = n + 1
--res1 = iterate add1 0         -- never terminates

{-
    Mapping and folding are other forms of repeated computation, as
    is filtering. When trying to describe a computation that requires
    repetition; try to think in terms of foldr, map, filter, iterate,
    and zipWith as these makeup roughly 90% of the computations that
    need repetition that you'll encounter.
    
    zipWith will terminate when the shortest list is exhausted
    
    filter as folding:
        filter keep = foldr op []
        where
            op x ys | keep x    = [x] ++ ys
                    | otherwise = ys
                    
    mapping as folding:
        map f = foldr op []
        where
            op x ys = [f x] ++ ys
            
    mapping as zipping:
        map f = zipWith op (repeat(error "ignored"))
        where
            op ignored x = f x
            
-}
{-
    PseudoRandom Numbers can be generated by taking the remainder of
    successive numbers divided by a fixed divisor with the previous
    number being multiplied by a fixed multiplier
    
    Eg      next x = (11*x) `mod` 127
            iterate next 1
-}
