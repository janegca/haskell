-- Ref: Two Dozen Short Lessons in Haskell by Rex Page
-- Chapter 22 - Recursion

import Data.List (partition)        -- used with qsort example
import Data.Char (isLower, isUpper, toLower)

{-
    To this point have covered serveral patterns of computation involving
    repetition:
        mapping - applying the same function to each element in a sequence
        folding - collapsing all elements in a sequence into one by
                  inserting a binary operation between each adjacent pair
        iterating - repeatedly apply a function to its own output
        filtering - forming a new sequence of elements from the elements
                    of an existing one that match a certain criteria
        (x:xs) - extracting a prefix or suffix from a sequence
        
    While these cover most repetition patterns, they do not cover them
    all; which means we need an mechanism to that allows us to specify
    arbitrary patterns of repetition.
        
    Recursive formula - a definition that contains a formula that refers
                        to the term being defined; all of the above
                        patterns can be described with a recursive
                        formula
                        
    Let's take the 'iterate' pattern as an example, it is defined
    in the Prelude as:
    
        iterate :: (a -> a) -> a -> [a]
        iterate f x =  x : iterate f (f x)

    From the type signature we can see it takes a function
    (a -> a), a second argument, 'a', and returns a sequence [a]
    
    The returned sequence is generated by repeatedly applying
    the iterate function to its own output

    eg iterate (2*) 1
       ==> 1 : iterate (2*) (2*1)
       ==> 1 : 2 : iterate (2*) (2*2)
       ==> 1 : 2 : 4 : iterate (2*) (2*4)
       ==> 1 : 2 : 4 : 8 : iterate (2*) (2*8)
       ==> and so on, and so on, and so on
       
       iterate f x
       ==> (f x) : iterate f ((f x))
       ==> (f x) : (f(f x)) : iterate f( (f(f x)) )
       ==> (f x) : (f(f x)) : (f(f(f x))) : iterate f(f(f(f x)))
       ==> etc
       
-}
{-
    Another example is the 'foldr' defined as recursion:
        foldr :: (a -> b -> b) -> b -> [a] -> b
        foldr op z (x : xs) = op x (foldr op z xs)
        foldr op z [ ] = z
        
    where,
        op      is a binary function                (a -> b -> b)
        z       is the zero or starting value       b
        (x:xs)  is a sequence                       [a]
        result  a single value                      b
        
    An example evaluation would be:
        foldr (+) 0 [1,2,3]
        ==> (+) 1 (foldr (+) 0 [2,3])           defn of foldr
        ==> 1 + (foldr (+) 0 [2,3])             apply (+)
        ==> 1 + ((+) 2 (foldr (+) 0 [3]))       defn of foldr
        ==> 1 + (2 + (foldr (+) 0 [3]))         apply (+)
        ==> 1 + (2 + ((+) 3 foldr 0 []))        defn of foldr
        ==> 1 + (2 + (3 + (foldr (+) 0 [])))    apply (+)
        ==> 1 + (2 + (3 + ( 0 )))               defn of foldr, case []
        ==> 1 + (2 + (3 + 0))                   apply +
        ==> 1 + (2 + 3)                         apply +
        ==> 1 + 5                               
        ==> 6
        
    Page says not to worry so much about how recursion operates
    but rather about correctly defining the relationship between
    the terms being defined.
    
    Try defining 'take' as recursion
-}
take' n (x:xs)
    | n > 0     = x : take (n-1) xs
    | n == 0    = []        -- take no elements
    | otherwise = error("take (" ++ show n ++ ") not allowed")
take' n [] = []
{-
    Using recursion to sort elements in a sequence based on 
    'quick sort' pattern.  The only thing we need to know about
    the elements is that they can be compared to determine which
    precedes the other.
    
    The basic pattern (as discovered by C.A.R. Hoare) is:
        1. Compare each element in the sequence to the first element
        2. Pile up the elements that should precede it in one pile
           and the elements that should succeed  it in another pile
        3. Apply the sort method to both piles (where recursion comes in)
        4. When done, build a sequence that:
            (a) begin with the now sorted elements of the first pile
            (b) followed by the first element
            (c) followed by the now sorted elements of the last pile
            
    Try defining it:
-}
quickSort :: Ord a => [a] -> [a]
quickSort (x:xs) = quickSort (filter (< x) xs)
                   ++ x : quickSort (filter (>= x) xs)
quickSort [] = []

{-
    This almost works correctly:
    
        *Main> quickSort ["Billy","Sue","Tom","Rita"]
        ["Billy","Rita","Sue","Tom"]
        *Main> quickSort[32, 5280, 12, 8]
        [8,12,32,5280]
        *Main> quickSort[129.92, -12.47, 59.99, 19.95]
        [-12.47,19.95,59.99,129.92]
        *Main> quickSort["Poe", "cummings", "Whitman", "Seuss", "Dylan"]
        ["Dylan","Poe","Seuss","Whitman","cummings"]    

    'cummings' should not have been last in the final sort. This
    happens because the '<' operator uses the ASCII value of each
    character to determine order; in the ASCII world, 'A' = 65 and
    'a' = 97 so uppercase letters precede lowercase letters.
    
    What we need is a 'precedes' function that determines the
    correct ordering; we can use it in place of '<'. 
   
    quickSortWith modifies quickSort to use a predicate
    function for comparing list values. When called with the
    'alphaOrder' function a list of strings is sorted in alpha
    order
    
    Example:
    
    *Main> quickSortWith alphaOrder ["Poe","Dylan","cummings","Whitman","Suess"]
    ["cummings","Dylan","Poe","Suess","Whitman"]
    
-}
quickSortWith p (x:xs) = quickSortWith p (filter (p x) xs)
                         ++ x : quickSortWith p (filter (not . (p x)) xs)
quickSortWith _ [] = []

{-
    This is somewhat counter-intuitive when used with the filter
    function in quickSortWith. The filter passes on all values
    that meet the given condition. If the first two elements
    of a list are "Poe" and "cummings", "Poe" becomes 'x' and
    and "cummings" becomes 'xs'
    
    The predicate (p x) means 'x' is 'fixed' as "Poe" and becomes 'a' 
    while the head of 'xs' becomes b, so alphaOrder is called as:
        alphaOrder "Poe" "cummings'
        ==> "Poe" > "cummings"
        ==> True
    
    Now, "cummings" is the current value from 'xs' that is 
    being checked so the 'True' is equated to 'cummings' and
    it is returned.
        
    On the other side, using (not . (p x)), we get 
        not . alphaOrder "Poe" "cummings"
        ==> not "Poe" > "cummings"
        ==> not True
        ==> False
        
    again, "cummings" is the current value being checked by the
    filter, it equates to False and so is not kept
    
-}
alphaOrder :: [Char] -> [Char] -> Bool
alphaOrder a b
    | a == b    = True                
    | otherwise = aLCase > bLCase   -- '<' gives descending sort
    where
        -- convert strings a and b to lowercase
        aLCase = map toLower a
        bLCase = map toLower b
        
-- using the 'partition' function from Data.List to split sequences
-- Source:
--  http://rosettacode.org/wiki/Sorting_algorithms/Quicksort#Haskell
--
-- this also missorts the "Poe", "cummings", etc. list
qsort (x:xs) = qsort ys ++ x : qsort zs 
               where (ys, zs) = partition (< x) xs
qsort [] = []

-- works ok with alphaOrder
qsort' p (x:xs) = qsort' p ys ++ x : qsort' p zs 
               where (ys, zs) = partition (p x) xs
qsort' _ [] = []

